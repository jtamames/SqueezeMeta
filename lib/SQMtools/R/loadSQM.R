require(reshape2)

#' Load a SqueezeMeta project into R
#'
#' This function takes the path to a project directory generated by \href{http://github.com/jtamames/SqueezeMeta}{SqueezeMeta} (whose name is specified in the \code{-p} parameter of the SqueezeMeta.pl script) and parses the results into a SQM object.
#'
#' @section Prerequisites:
#' {
#' \enumerate{
#'     \item Run \href{http://github.com/jtamames/SqueezeMeta}{SqueezeMeta}! An example call for running it would be:
#'
#'         \code{/path/to/SqueezeMeta/scripts/SqueezeMeta.pl}\cr
#'         \code{-m coassembly -f fastq_dir -s samples_file -p project_dir}
#'     \item Generate tabular outputs with the \code{sqm2tables.py} script included in the \code{path/to/SqueezeMeta/utils} directory:
#'
#'         \code{/path/to/SqueezeMeta/utils/sqm2tables.py project_dir project_dir/results/tables}
#'     }
#' }
#' 
#' @section The SQM object structure:
#' {
#' The SQM object is a nested list which contains the following information:
#' \tabular{lllllll}{
#' \bold{lvl1}         \tab \bold{lvl2}               \tab \bold{lvl3}          \tab \bold{type}             \tab \bold{rows/names} \tab \bold{columns} \tab \bold{data}        \cr
#' \bold{$orfs}        \tab \bold{$table}             \tab                      \tab \emph{dataframe}        \tab orfs              \tab misc. data     \tab misc. data         \cr
#'                     \tab \bold{$abund}             \tab                      \tab \emph{numeric matrix}   \tab orfs              \tab samples        \tab abundances (reads) \cr
#'                     \tab \bold{$bases}             \tab                      \tab \emph{numeric matrix}   \tab orfs              \tab samples        \tab abundances (bases) \cr
#'                     \tab \bold{$tpm}               \tab                      \tab \emph{numeric matrix}   \tab orfs              \tab samples        \tab tpm                \cr
#'                     \tab \bold{$seqs}              \tab                      \tab \emph{character vector} \tab orfs              \tab (n/a)          \tab sequences          \cr
#'                     \tab \bold{$tax}               \tab                      \tab \emph{character matrix} \tab orfs              \tab tax. ranks     \tab taxonomy           \cr
#' \bold{$contigs}     \tab \bold{$table}             \tab                      \tab \emph{dataframe}        \tab contigs           \tab misc. data     \tab misc. data         \cr
#'                     \tab \bold{$abund}             \tab                      \tab \emph{numeric matrix}   \tab contigs           \tab samples        \tab abundances (reads) \cr
#'                     \tab \bold{$tpm}               \tab                      \tab \emph{numeric matrix}   \tab contigs           \tab samples        \tab tpm                \cr
#'                     \tab \bold{$seqs}              \tab                      \tab \emph{character vector} \tab contigs           \tab (n/a)          \tab sequences          \cr
#'                     \tab \bold{$tax}               \tab                      \tab \emph{character matrix} \tab contigs           \tab tax. ranks     \tab taxonomies         \cr
#'                     \tab \bold{$bins}              \tab                      \tab \emph{character matrix} \tab contigs           \tab bin. methods   \tab bins               \cr
#' $bins               \tab \bold{$table}             \tab                      \tab \emph{dataframe}        \tab bins              \tab misc. data     \tab misc. data         \cr
#'                     \tab \bold{$tpm}               \tab                      \tab \emph{numeric matrix}   \tab bins              \tab samples        \tab tpm                \cr
#'                     \tab \bold{$tax}               \tab                      \tab \emph{character matrix} \tab bins              \tab tax. ranks     \tab taxonomy           \cr
#' \bold{$taxa}        \tab \bold{$superkingdom}      \tab \bold{$abund}        \tab \emph{numeric matrix}   \tab superkingdoms     \tab samples        \tab abundances (reads) \cr
#'                     \tab                           \tab \bold{$percent}      \tab \emph{numeric matrix}   \tab superkingdoms     \tab samples        \tab percentages        \cr
#'                     \tab \bold{$phylum}            \tab \bold{$abund}        \tab \emph{numeric matrix}   \tab phyla             \tab samples        \tab abundances (reads) \cr
#'                     \tab                           \tab \bold{$percent}      \tab \emph{numeric matrix}   \tab phyla             \tab samples        \tab percentages        \cr
#'                     \tab \bold{$class}             \tab \bold{$abund}        \tab \emph{numeric matrix}   \tab classes           \tab samples        \tab abundances (reads) \cr
#'                     \tab                           \tab \bold{$percent}      \tab \emph{numeric matrix}   \tab classes           \tab samples        \tab percentages        \cr
#'                     \tab \bold{$order}             \tab \bold{$abund}        \tab \emph{numeric matrix}   \tab orders            \tab samples        \tab abundances (reads) \cr
#'                     \tab                           \tab \bold{$percent}      \tab \emph{numeric matrix}   \tab orders            \tab samples        \tab percentages        \cr
#'                     \tab \bold{$family}            \tab \bold{$abund}        \tab \emph{numeric matrix}   \tab families          \tab samples        \tab abundances (reads) \cr
#'                     \tab                           \tab \bold{$percent}      \tab \emph{numeric matrix}   \tab families          \tab samples        \tab percentages        \cr
#'                     \tab \bold{$genus}             \tab \bold{$abund}        \tab \emph{numeric matrix}   \tab genera            \tab samples        \tab abundances (reads) \cr
#'                     \tab                           \tab \bold{$percent}      \tab \emph{numeric matrix}   \tab genera            \tab samples        \tab percentages        \cr
#'                     \tab \bold{$species}           \tab \bold{$abund}        \tab \emph{numeric matrix}   \tab species           \tab samples        \tab abundances (reads) \cr
#'                     \tab                           \tab \bold{$percent}      \tab \emph{numeric matrix}   \tab species           \tab samples        \tab percentages        \cr
#' \bold{$functions}   \tab \bold{$KEGG}              \tab \bold{$abund}        \tab \emph{numeric matrix}   \tab KEGG ids          \tab samples        \tab abundances (reads) \cr
#'                     \tab                           \tab \bold{$bases}        \tab \emph{numeric matrix}   \tab KEGG ids          \tab samples        \tab abundances (bases) \cr
#'                     \tab                           \tab \bold{$tpm}          \tab \emph{numeric matrix}   \tab KEGG ids          \tab samples        \tab tpm                \cr
#'                     \tab                           \tab \bold{$copy_number}  \tab \emph{numeric matrix}   \tab KEGG ids          \tab samples        \tab avg. copies        \cr
#'                     \tab \bold{$COG}               \tab \bold{$abund}        \tab \emph{numeric matrix}   \tab COG ids           \tab samples        \tab abundances (reads) \cr
#'                     \tab                           \tab \bold{$bases}        \tab \emph{numeric matrix}   \tab COG ids           \tab samples        \tab abundances (bases) \cr
#'                     \tab                           \tab \bold{$tpm}          \tab \emph{numeric matrix}   \tab COG ids           \tab samples        \tab tpm                \cr
#'                     \tab                           \tab \bold{$copy_number}  \tab \emph{numeric matrix}   \tab COG ids           \tab samples        \tab avg. copies        \cr
#'                     \tab \bold{$PFAM}              \tab \bold{$abund}        \tab \emph{numeric matrix}   \tab PFAM ids          \tab samples        \tab abundances (reads) \cr
#'                     \tab                           \tab \bold{$bases}        \tab \emph{numeric matrix}   \tab PFAM ids          \tab samples        \tab abundances (bases) \cr
#'                     \tab                           \tab \bold{$tpm}          \tab \emph{numeric matrix}   \tab PFAM ids          \tab samples        \tab tpm                \cr
#'                     \tab                           \tab \bold{$copy_number}  \tab \emph{numeric matrix}   \tab PFAM ids          \tab samples        \tab avg. copies        \cr
#' \bold{$total_reads} \tab                           \tab                      \tab \emph{numeric vector}   \tab samples           \tab (n/a)          \tab total reads        \cr
#' \bold{$misc}        \tab \bold{$project_name}      \tab                      \tab \emph{character vector} \tab (empty)           \tab (n/a)          \tab project name       \cr
#'                     \tab \bold{$samples}           \tab                      \tab \emph{character vector} \tab (empty)           \tab (n/a)          \tab samples            \cr
#'                     \tab \bold{$tax_names_long}    \tab \bold{$superkingdom} \tab \emph{character vector} \tab short names       \tab (n/a)          \tab full names         \cr
#'                     \tab                           \tab \bold{$phylum}       \tab \emph{character vector} \tab short names       \tab (n/a)          \tab full names         \cr
#'                     \tab                           \tab \bold{$class}        \tab \emph{character vector} \tab short names       \tab (n/a)          \tab full names         \cr
#'                     \tab                           \tab \bold{$order}        \tab \emph{character vector} \tab short names       \tab (n/a)          \tab full names         \cr
#'                     \tab                           \tab \bold{$family}       \tab \emph{character vector} \tab short names       \tab (n/a)          \tab full names         \cr
#'                     \tab                           \tab \bold{$genus}        \tab \emph{character vector} \tab short names       \tab (n/a)          \tab full names         \cr
#'                     \tab                           \tab \bold{$species}      \tab \emph{character vector} \tab short names       \tab (n/a)          \tab full names         \cr
#'                     \tab \bold{$tax_names_short}   \tab                      \tab \emph{character vector} \tab full names        \tab (n/a)          \tab short names        \cr
#'                     \tab \bold{$KEGG_names}        \tab                      \tab \emph{character vector} \tab KEGG ids          \tab (n/a)          \tab KEGG names         \cr
#'                     \tab \bold{$KEGG_paths}        \tab                      \tab \emph{character vector} \tab KEGG ids          \tab (n/a)          \tab KEGG hiararchy     \cr
#'                     \tab \bold{$COG_names}         \tab                      \tab \emph{character vector} \tab COG ids           \tab (n/a)          \tab COG names          \cr
#'                     \tab \bold{$COG_paths}         \tab                      \tab \emph{character vector} \tab COG ids           \tab (n/a)          \tab COG hierarchy      \cr
#'                     \tab \bold{$ext_annot_sources} \tab                      \tab \emph{character vector} \tab COG ids           \tab (n/a)          \tab external databases \cr
#' }
#' If external databases for functional classification were provided to SqueezeMeta via the \code{-extdb} argument, the corresponding abundance (reads and bases), tpm and copy number profiles will be present in \code{SQM$functions} (e.g. results for the CAZy database would be present in \code{SQM$functions$CAZy}). Additionally, the extended names of the features present in the external database will be present in \code{SQM$misc} (e.g. \code{SQM$misc$CAZy_names}).
#' }
#' @param project_path character, project directory generated by SqueezeMeta. 
#' @param tax_mode character, which taxonomic classification should be loaded? SqueezeMeta applies the identity thresholds described in \href{https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4005636/}{Luo \emph{et al.}, 2014}. Use \code{allfilter} for applying the minimum identity threshold to all taxa (default) and \code{prokfilter} for applying the threshold to Bacteria and Archaea, but not to Eukaryotes.
#' @return SQM object containing the parsed project.
#' @examples
#' \dontrun{
#' # (outside R)
#' /path/to/SqueezeMeta/scripts/SqueezeMeta.pl -p Hadza -f raw -m coassembly -s test.samples # Run SqueezeMeta on the test data
#' /path/to/SqueezeMeta/utils/sqm2tables.py Hadza Hadza/results/tables # Generate the tabular outputs! They must be placed in the <project name>/results/tables directory!
#' # now go into R
#' R
#' library(SQMtools)
#' Hadza = loadSQM("Hadza") # Where Hadza is the path to the SqueezeMeta output directory
#' }
#'
#' data(Hadza)
#' # Which are the ten most abundant KEGG IDs in our data?
#' topKEGG = sort(rowSums(Hadza$functions$KEGG$tpm), decreasing=T)[1:11]
#' topKEGG = topKEGG[names(topKEGG)!="Unclassified"]
#' # Which functions do those KEGG IDs represent?
#' Hadza$misc$KEGG_names[topKEGG]
#' What is the relative abundance of the Gammaproteobacteria class across samples?
#' Hadza$taxa$class$percent["Gammaproteobacteria",]
#' # Which information is stored in the orf, contig and bin tables?
#' colnames(Hadza$orfs$table)
#' colnames(Hadza$contigs$table)
#' colnames(Hadza$bins$table)
#' # What is the GC content distribution of my metagenome?
#' boxplot(Hadza$contigs$table[,"GC perc"]) # Not weighted by contig length or abundance!
#' @export

loadSQM = function(project_path, tax_mode = 'allfilter')
    {
    
    if(!tax_mode %in% c('allfilter', 'prokfilter'))
        {
        stop('tax_mode must be either \'allfilter\' (apply minimum identity threshold for all taxa) or \'prokfilter\' (don\'t appy thresholds to Eukaryotes)')
        }

    # include my hierarchy somehow?? -> sqm2tables, aggregate KEGG hierarchy levels??
    
    SQM                          = list()
    
    project_name                 = tail(unlist(strsplit(project_path, split='/')), 1)
    SQM$misc                     = list()
    SQM$misc$project_name        = project_name

    cat('Loading orfs\n')
    SQM$orfs                     = list()

    cat('    table...\n')        # option to remove table from memory after getting abund & TPM?
    SQM$orfs$table               = read.table(sprintf('%s/results/13.%s.orftable', project_path, project_name),
                                              header=T, sep='\t', row.names=1, quote='', comment.char='', skip=1, as.is=TRUE, check.names=F)
    cat('    abundances...\n')
    SQM$orfs$abund               = as.matrix(SQM$orfs$table[,grepl('Raw read count', colnames(SQM$orfs$table)),drop=F])
    colnames(SQM$orfs$abund)     = gsub('Raw read count ', '', colnames(SQM$orfs$abund), fixed=T)
    SQM$orfs$bases               = as.matrix(SQM$orfs$table[,grepl('Raw base count', colnames(SQM$orfs$table)),drop=F])
    colnames(SQM$orfs$bases)     = gsub('Raw base count ', '', colnames(SQM$orfs$abund), fixed=T)
    SQM$orfs$cov                 = as.matrix(SQM$orfs$table[,grepl('Coverage', colnames(SQM$orfs$table)),drop=F])
    colnames(SQM$orfs$cov)       = gsub('Coverage ', '', colnames(SQM$orfs$cov), fixed=T)
    SQM$orfs$tpm                 = as.matrix(SQM$orfs$table[,grepl('TPM', colnames(SQM$orfs$table)),drop=F])
    colnames(SQM$orfs$tpm)       = gsub('TPM ', '', colnames(SQM$orfs$tpm), fixed=T)
    SQM$misc$samples             = colnames(SQM$orfs$abund)
    
    cat('    sequences\n')    
    SQM$orfs$seqs                = read.namedvector(sprintf('%s/results/tables/%s.orf.sequences.tsv', project_path, project_name))
    
    cat('    taxonomy...\n')
    SQM$orfs$tax                 = as.matrix(read.table(sprintf('%s/results/tables/%s.orf.tax.%s.tsv', project_path, project_name, tax_mode),
                                                        header=T, row.names=1, sep='\t'))
    # Remove orfs with no nt length (which should be fixed at some point). The tax table contains the correct number of orfs.
    SQM$orfs$table               = SQM$orfs$table[rownames(SQM$orfs$table) %in% rownames(SQM$orfs$tax),]
    SQM$orfs$abund               = SQM$orfs$abund[rownames(SQM$orfs$table),,drop=F]
    SQM$orfs$tpm                 = SQM$orfs$tpm[rownames(SQM$orfs$table),,drop=F]
    SQM$orfs$seqs                = SQM$orfs$seqs[rownames(SQM$orfs$table)[rownames(SQM$orfs$table) %in% names(SQM$orfs$seqs)]]
   
    # Load KEGG/COG/others names and paths as misc data
    KEGGids                      = SQM$orfs$table[,'KEGG ID']
    KEGGids                      = gsub('*', '', KEGGids, fixed=T)
    KEGGnames                    = SQM$orfs$table[,'KEGGFUN']
    KEGGnames                    = KEGGnames[KEGGids!='' & !grepl(';', KEGGids, fixed=T)]
    SQM$misc$KEGG_names          = KEGGnames
    names(SQM$misc$KEGG_names)   = KEGGids  [KEGGids!='' & !grepl(';', KEGGids, fixed=T)]
    SQM$misc$KEGG_names          = SQM$misc$KEGG_names[unique(names(SQM$misc$KEGG_names))]
    KEGGpaths                    = SQM$orfs$table[,'KEGGPATH']
    KEGGpaths                    = KEGGpaths[KEGGids!='' & !grepl(';', KEGGids, fixed=T)]
    SQM$misc$KEGG_paths          = KEGGpaths
    names(SQM$misc$KEGG_paths)   = KEGGids  [KEGGids!='' & !grepl(';', KEGGids, fixed=T)]
    SQM$misc$KEGG_paths          = SQM$misc$KEGG_paths[unique(names(SQM$misc$KEGG_paths))]

    COGids                       = SQM$orfs$table[,'COG ID']
    COGids                       = gsub('*', '', COGids, fixed=T)
    COGnames                     = SQM$orfs$table[,'COGFUN']
    COGnames                     = COGnames[COGids!='' & !grepl(';', COGids, fixed=T)]
    SQM$misc$COG_names           = COGnames
    names(SQM$misc$COG_names)    = COGids  [COGids!='' & !grepl(';', COGids, fixed=T)]
    SQM$misc$COG_names           = SQM$misc$COG_names[unique(names(SQM$misc$COG_names))]
    COGpaths                     = SQM$orfs$table[,'COGPATH']
    COGpaths                     = COGpaths[COGids!='' & !grepl(';', COGids, fixed=T)]
    SQM$misc$COG_paths           = COGpaths
    names(SQM$misc$COG_paths)    = COGids  [COGids!='' & !grepl(';', COGids, fixed=T)]
    SQM$misc$COG_paths           = SQM$misc$COG_paths[unique(names(SQM$misc$COG_names))]

    result_files                 = strsplit(list.files(sprintf('%s/results', project_path)), '.', fixed=T)
    external_annotation_results  = result_files[sapply(result_files, FUN=function(x) length(x)>2 & x[3]=='fun3' & !x[4] %in% c('kegg', 'cog', 'pfam', 'tax'))]
    SQM$misc$ext_annot_sources   = sapply(external_annotation_results, FUN=function(x) x[4])
    for(method in SQM$misc$ext_annot_sources)
        {
        ids = SQM$orfs$table[,method]
        ids = gsub('*', '', ids, fixed=T)
        names = SQM$orfs$table[,sprintf('%s NAME', method)]
        names = names[ids!=''] # We assume that there are not multiple annotations like in KEGG or COG. # names[ids!='' & !grepl(';', ids, fixed=T)]
        field = sprintf('%s_names', method)
        SQM$misc[[field]] = names
        names(SQM$misc[[field]]) = ids[ids!=''] #  We assume that there are not multiple annotations like in KEGG or COG. # ids[ids!='' & !grepl(';', ids, fixed=T)]
        SQM$misc[[field]] = SQM$misc[[field]][unique(names(SQM$misc[[field]]))]
        }


    cat('Loading contigs\n')
    SQM$contigs                   = list()

    cat('    table...\n')                    # option to remove table from memory after getting abund & TPM?
    SQM$contigs$table             = read.table(sprintf('%s/results/20.%s.contigtable', project_path, project_name),
                                                       header=T, sep='\t', row.names=1, quote='', comment.char='', skip=1, as.is=T, check.names=F)
    cat('    abundances...\n')
    SQM$contigs$abund             = as.matrix(SQM$contigs$table[,grepl('Raw read count', colnames(SQM$contigs$table)),drop=F])
    colnames(SQM$contigs$abund)   = gsub('Raw read count ', '', colnames(SQM$contigs$abund), fixed=T)
    SQM$contigs$cov               = as.matrix(SQM$contigs$table[,grepl('Coverage', colnames(SQM$contigs$table)),drop=F])
    colnames(SQM$contigs$cov)     = gsub('Coverage ', '', colnames(SQM$contigs$cov), fixed=T)
    SQM$contigs$tpm               = as.matrix(SQM$contigs$table[,grepl('TPM', colnames(SQM$contigs$table)),drop=F])
    colnames(SQM$contigs$tpm)     = gsub('TPM ', '', colnames(SQM$contigs$tpm), fixed=T)

    cat('    sequences...\n')                                                 
    SQM$contigs$seqs              = read.namedvector(sprintf('%s/results/tables/%s.contig.sequences.tsv', project_path, project_name))
    SQM$contigs$seqs              = SQM$contigs$seqs[rownames(SQM$contigs$table)]

    cat('    taxonomy...\n')
    SQM$contigs$tax               = as.matrix(read.table(sprintf('%s/results/tables/%s.contig.tax.tsv', project_path, project_name),
                                                         header=T, row.names=1, sep='\t'))
    SQM$contigs$tax               = SQM$contigs$tax[rownames(SQM$contigs$table),]

					  
    if(file.exists(sprintf('%s/results/19.%s.bintable', project_path, project_name)))
        {
        cat('    binning info...\n')
        inBins                    = read.table(sprintf('%s/intermediate/19.%s.contigsinbins', project_path, project_name),
                                               header=T, sep='\t', quote='', comment.char='', skip=1, as.is=T)
        inBins                    = reshape2::dcast(inBins, X..Contig~Method, value.var="Bin.ID")
        rownames(inBins)          = inBins[,1]
        SQM$contigs$bins          = as.matrix(inBins[,-1,drop=F])
        notInBins                 = setdiff(rownames(SQM$contigs$table), SQM$contigs$bins)
        notInBins                 = matrix(NA, nrow=length(notInBins), ncol=ncol(SQM$contigs$bins), dimnames=list(notInBins, colnames(SQM$contigs$bins)))
        SQM$contigs$bins          = rbind(SQM$contigs$bins, notInBins)
        SQM$contigs$bins          = SQM$contigs$bins[rownames(SQM$contigs$table),,drop=F]
        SQM$contigs$bins[is.na(SQM$contigs$bins)] = 'No_bin'

        cat('Loading bins\n')
        cat('    table...\n')
        SQM$bins                  = list()
        SQM$bins$table            = read.table(sprintf('%s/results/19.%s.bintable', project_path, project_name),
                                               header=T, sep='\t', row.names=1, quote='', comment.char='', skip=1, as.is=T, check.names=F)
        cat('    abundances...\n')
        SQM$bins$tpm              = as.matrix(SQM$bins$table[,grepl('TPM', colnames(SQM$bins$table)),drop=F])
        colnames(SQM$bins$tpm)    = gsub('TPM ', '', colnames(SQM$bins$tpm), fixed=T)
        cat('    taxonomy...\n')
        SQM$bins$tax              = as.matrix(read.table(sprintf('%s/results/tables/%s.bin.tax.tsv', project_path, project_name),
                                                         header=T, row.names=1, sep='\t'))
	}
    cat('Loading taxonomies\n')                                   
    SQM$taxa                      = list()
    SQM$taxa$superkingdom         = list()
    SQM$taxa$phylum               = list()
    SQM$taxa$class                = list()
    SQM$taxa$order                = list()
    SQM$taxa$family               = list()
    SQM$taxa$genus                = list()
    SQM$taxa$species              = list()
    

    SQM$taxa$superkingdom$abund   = as.matrix(read.table(sprintf('%s/results/tables/%s.superkingdom.%s.abund.tsv', project_path, project_name, tax_mode, project_name),
                                                         header=T, sep='\t', row.names=1, check.names=F))
    SQM$taxa$phylum$abund         = as.matrix(read.table(sprintf('%s/results/tables/%s.phylum.%s.abund.tsv', project_path, project_name, tax_mode),
                                                         header=T, sep='\t', row.names=1, check.names=F))
    SQM$taxa$class$abund          = as.matrix(read.table(sprintf('%s/results/tables/%s.class.%s.abund.tsv', project_path, project_name, tax_mode),
                                                         header=T, sep='\t', row.names=1, check.names=F))
    SQM$taxa$order$abund          = as.matrix(read.table(sprintf('%s/results/tables/%s.order.%s.abund.tsv', project_path, project_name, tax_mode),
                                                         header=T, sep='\t', row.names=1, check.names=F))
    SQM$taxa$family$abund         = as.matrix(read.table(sprintf('%s/results/tables/%s.family.%s.abund.tsv', project_path, project_name, tax_mode),
                                                         header=T, sep='\t', row.names=1, check.names=F))
    SQM$taxa$genus$abund          = as.matrix(read.table(sprintf('%s/results/tables/%s.genus.%s.abund.tsv', project_path, project_name, tax_mode),
                                                         header=T, sep='\t', row.names=1, check.names=F))
    SQM$taxa$species$abund        = as.matrix(read.table(sprintf('%s/results/tables/%s.species.%s.abund.tsv', project_path, project_name, tax_mode),
                                                         header=T, sep='\t', row.names=1, check.names=F))
                                                          
     
    SQM$taxa$superkingdom$percent = 100 * t(t(SQM$taxa$superkingdom$abund) / colSums(SQM$taxa$superkingdom$abund))
    SQM$taxa$phylum$percent       = 100 * t(t(SQM$taxa$phylum$abund)       / colSums(SQM$taxa$phylum$abund      ))
    SQM$taxa$class$percent        = 100 * t(t(SQM$taxa$class$abund)        / colSums(SQM$taxa$class$abund       )) 
    SQM$taxa$order$percent        = 100 * t(t(SQM$taxa$order$abund)        / colSums(SQM$taxa$order$abund       ))
    SQM$taxa$family$percent       = 100 * t(t(SQM$taxa$family$abund)       / colSums(SQM$taxa$family$abund      ))
    SQM$taxa$genus$percent        = 100 * t(t(SQM$taxa$genus$abund)        / colSums(SQM$taxa$genus$abund       ))
    SQM$taxa$species$percent      = 100 * t(t(SQM$taxa$species$abund)      / colSums(SQM$taxa$species$abund     ))

    
    SQM$misc$tax_names_long                 = list()

    SQM$misc$tax_names_long$superkingdom    = rownames(SQM$tax$superkingdom$abund)
    names(SQM$misc$tax_names_long$superkingdom) = gsub('^k_', '', SQM$misc$tax_names_long$superkingdom)

    SQM$misc$tax_names_long$phylum          = rownames(SQM$tax$phylum$abund)
    names(SQM$misc$tax_names_long$phylum)   = sapply(strsplit(SQM$misc$tax_names_long$phylum,  split=';p_'), FUN = function(x) x[2])

    SQM$misc$tax_names_long$class           = rownames(SQM$tax$class$abund)
    names(SQM$misc$tax_names_long$class)    = sapply(strsplit(SQM$misc$tax_names_long$class,   split=';c_'), FUN = function(x) x[2])

    SQM$misc$tax_names_long$order           = rownames(SQM$tax$order$abund)
    names(SQM$misc$tax_names_long$order)    = sapply(strsplit(SQM$misc$tax_names_long$order,   split=';o_'), FUN = function(x) x[2])

    SQM$misc$tax_names_long$family          = rownames(SQM$tax$family$abund)
    names(SQM$misc$tax_names_long$family)   = sapply(strsplit(SQM$misc$tax_names_long$family,  split=';f_'), FUN = function(x) x[2])

    SQM$misc$tax_names_long$genus           = rownames(SQM$tax$genus$abund)
    names(SQM$misc$tax_names_long$genus)    = sapply(strsplit(SQM$misc$tax_names_long$genus,   split=';g_'), FUN = function(x) x[2])

    SQM$misc$tax_names_long$species         = rownames(SQM$tax$species$abund)
    names(SQM$misc$tax_names_long$species)  = sapply(strsplit(SQM$misc$tax_names_long$species, split=';s_'), FUN = function(x) x[2]) 

    SQM$misc$tax_names_short                = unlist(lapply(SQM$misc$tax_names_long, names))
    names(SQM$misc$tax_names_short)         = unlist(SQM$misc$tax_names_long)


    # Use short names for taxonomy tables, since it makes it easier to search for specific taxa
    rownames(SQM$taxa$superkingdom$abund)   = SQM$misc$tax_names_short[rownames(SQM$taxa$superkingdom$abund)]
    rownames(SQM$taxa$phylum$abund)         = SQM$misc$tax_names_short[rownames(SQM$taxa$phylum$abund)]
    rownames(SQM$taxa$class$abund)          = SQM$misc$tax_names_short[rownames(SQM$taxa$class$abund)]
    rownames(SQM$taxa$order$abund)          = SQM$misc$tax_names_short[rownames(SQM$taxa$order$abund)]
    rownames(SQM$taxa$family$abund)         = SQM$misc$tax_names_short[rownames(SQM$taxa$family$abund)]
    rownames(SQM$taxa$genus$abund)          = SQM$misc$tax_names_short[rownames(SQM$taxa$genus$abund)]
    rownames(SQM$taxa$species$abund)        = SQM$misc$tax_names_short[rownames(SQM$taxa$species$abund)]

    rownames(SQM$taxa$superkingdom$percent) = SQM$misc$tax_names_short[rownames(SQM$taxa$superkingdom$percent)]
    rownames(SQM$taxa$phylum$percent)       = SQM$misc$tax_names_short[rownames(SQM$taxa$phylum$percent)]
    rownames(SQM$taxa$class$percent)        = SQM$misc$tax_names_short[rownames(SQM$taxa$class$percent)]
    rownames(SQM$taxa$order$percent)        = SQM$misc$tax_names_short[rownames(SQM$taxa$order$percent)]
    rownames(SQM$taxa$family$percent)       = SQM$misc$tax_names_short[rownames(SQM$taxa$family$percent)]
    rownames(SQM$taxa$genus$percent)        = SQM$misc$tax_names_short[rownames(SQM$taxa$genus$percent)]
    rownames(SQM$taxa$species$percent)      = SQM$misc$tax_names_short[rownames(SQM$taxa$species$percent)]


    cat('Loading functions\n')
    SQM$functions                  = list()
    ### KEGG
    SQM$functions$KEGG             = list()
    if(file.exists(sprintf('%s/results/tables/%s.KO.abund.tsv', project_path, project_name)))
        {
        has_KEGG                               = TRUE
        SQM$functions$KEGG$abund               = as.matrix(read.table(sprintf('%s/results/tables/%s.KO.abund.tsv', project_path, project_name),
                                                                      header=T, sep='\t', row.names=1, check.names=F, comment.char='', quote=''))
        SQM$functions$KEGG$bases               = as.matrix(read.table(sprintf('%s/results/tables/%s.KO.bases.tsv', project_path, project_name),
                                                                      header=T, sep='\t', row.names=1, check.names=F, comment.char='', quote=''))
        SQM$functions$KEGG$tpm                 = as.matrix(read.table(sprintf('%s/results/tables/%s.KO.tpm.tsv', project_path, project_name),
                                                                      header=T, sep='\t', row.names=1, check.names=F, comment.char='', quote=''))
    }else
        {
        warning('    There are no KEGG results in your project. Skipping...')
        has_KEGG                               = FALSE
        SQM$functions$KEGG$abund               = NULL # Just being needessly explicit here
        SQM$functions$KEGG$bases               = NULL # Just being needessly explicit here
        SQM$functions$KEGG$tpm                 = NULL # Just being needessly explicit here
        }
    ### COG              
    if(file.exists(sprintf('%s/results/tables/%s.COG.abund.tsv', project_path, project_name)))
        {
        has_COG = TRUE
        SQM$functions$COG                      = list()
        SQM$functions$COG$abund                = as.matrix(read.table(sprintf('%s/results/tables/%s.COG.abund.tsv', project_path, project_name),
                                                                      header=T, sep='\t', row.names=1, check.names=F, comment.char='', quote=''))
        SQM$functions$COG$bases                = as.matrix(read.table(sprintf('%s/results/tables/%s.COG.bases.tsv', project_path, project_name),
                                                                      header=T, sep='\t', row.names=1, check.names=F, comment.char='', quote=''))
        SQM$functions$COG$tpm                  = as.matrix(read.table(sprintf('%s/results/tables/%s.COG.tpm.tsv', project_path, project_name),
                                                                      header=T, sep='\t', row.names=1, check.names=F, comment.char='', quote=''))
    }else
        {
        warning('    There are no COG results in your project. Skipping...')
        has_COG                            = FALSE
        SQM$functions$COG$abund            = NULL # Just being needessly explicit here
        SQM$functions$COG$bases            = NULL # Just being needessly explicit here
        SQM$functions$COG$tpm              = NULL # Just being needessly explicit here
        }
    ### PFAM
    SQM$functions$PFAM                     = list()
    if(file.exists(sprintf('%s/results/tables/%s.PFAM.abund.tsv', project_path, project_name)))
        {
        has_PFAM = TRUE
        SQM$functions$PFAM$abund           = as.matrix(read.table(sprintf('%s/results/tables/%s.PFAM.abund.tsv', project_path, project_name),
                                                                  header=T, sep='\t', row.names=1, check.names=F, comment.char='', quote=''))
        SQM$functions$PFAM$bases           = as.matrix(read.table(sprintf('%s/results/tables/%s.PFAM.bases.tsv', project_path, project_name),
                                                                  header=T, sep='\t', row.names=1, check.names=F, comment.char='', quote=''))
        SQM$functions$PFAM$tpm             = as.matrix(read.table(sprintf('%s/results/tables/%s.PFAM.tpm.tsv', project_path, project_name),
                                                                  header=T, sep='\t', row.names=1, check.names=F, comment.char='', quote=''))
    }else
        {
        warning('    There are no PFAM results in your project. Skipping...')
        has_PFAM                           = FALSE
        SQM$functions$PFAM$abund           = NULL # Just being needlessly explicit here
        SQM$functions$PFAM$bases           = NULL # Just being needlessly explicit here
        SQM$functions$PFAM$tpm             = NULL # Just being needlessly explicit here
        }

    ### EXTERNAL ANNOTATION SOURCES
    for(method in SQM$misc$ext_annot_sources)
        {
        SQM$functions[[method]] = list()
	SQM$functions[[method]]$abund      = as.matrix(read.table(sprintf('%s/results/tables/%s.%s.abund.tsv', project_path, project_name, method),
                                                                  header=T, sep='\t', row.names=1, check.names=F, comment.char='', quote=''))
        SQM$functions[[method]]$bases      = as.matrix(read.table(sprintf('%s/results/tables/%s.%s.bases.tsv', project_path, project_name, method),
                                                                  header=T, sep='\t', row.names=1, check.names=F, comment.char='', quote=''))
        SQM$functions[[method]]$tpm        = as.matrix(read.table(sprintf('%s/results/tables/%s.%s.tpm.tsv', project_path, project_name, method),
                                                                  header=T, sep='\t', row.names=1, check.names=F, comment.char='', quote=''))
        }

    ### COPY NUMBERS
    if(file.exists(sprintf('%s/results/tables/%s.RecA.tsv', project_path, project_name)))
        {
        ### KEGG
        if(has_KEGG)
            {
            SQM$functions$KEGG$copy_number = as.matrix(read.table(sprintf('%s/results/tables/%s.KO.copyNumber.tsv', project_path, project_name),
                                                                  header=T, sep='\t', row.names=1, check.names=F, comment.char='', quote=''))
        }else
            {
            SQM$functions$KEGG$copy_number = NULL # Just being explicit here
            }
        ### COG
        if(has_COG)
            {
            SQM$functions$COG$copy_number  = as.matrix(read.table(sprintf('%s/results/tables/%s.COG.copyNumber.tsv', project_path, project_name),
                                                                  header=T, sep='\t', row.names=1, check.names=F, comment.char='', quote=''))
        }else
            {
            SQM$functions$COG$copy_number  = NULL # Just being explicit here
            }
        ### PFAM
        if(has_PFAM)
            {
            SQM$functions$PFAM$copy_number = as.matrix(read.table(sprintf('%s/results/tables/%s.PFAM.copyNumber.tsv', project_path, project_name),
                                                                  header=T, sep='\t', row.names=1, check.names=F, comment.char='', quote=''))
        }else
            {
            SQM$functions$PFAM$copy_number = NULL # Just being explicit here
            }
	### EXTERNAL ANNOTATION SOURCES
	for(method in SQM$misc$ext_annot_sources)
            {                              # :'(
            SQM$functions[[method]]$copy_number = as.matrix(read.table(sprintf('%s/results/tables/%s.%s.copyNumber.tsv', project_path, project_name, method),
                                                                       header=T, sep='\t', row.names=1, check.names=F, comment.char='', quote=''))
            }
        ### RecA coverage
        SQM$misc$RecA_cov                       = unlist(read.table(sprintf('%s/results/tables/%s.RecA.tsv', project_path, project_name),
                                                                    header=T, row.names=1) ['COG0468',] )
    }else
        {
        warning('    There are no copy number tables in your project, possibly because COG annotation was not performed or RecA was not present in the metagenome')
        SQM$misc$RecA_cov                  = NULL # Just being explicit here
        }


    cat('Loading total reads\n')
    SQM$total_reads = as.matrix(
                                read.table(sprintf('%s/results/10.%s.mappingstat', project_path, project_name), 
                                           header=T, sep='\t', row.names=1, skip=1, comment.char='')
                               )[,'Total.reads']

    class(SQM)      = 'SQM'

    return(SQM)

    }

